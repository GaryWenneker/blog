---
layout: post
title: 'Sitecore JSS: Development Modes'
date: 1970-01-18 19:32:08.000000000 +01:00
---
<p>Sitecore JSS is the new way of developing in and with Sitecore. The <a href="https://jss.sitecore.net/docs/getting-started/quick-start">quickstart </a>is pretty straightforward when it comes to the disconnected mode. This blog also focuses on the <a href="https://jss.sitecore.net/docs/fundamentals/dev-workflows/code-first">Code-First workflow</a> and the <a href="https://jss.sitecore.net/docs/fundamentals/dev-workflows/sitecore-first">Sitecore-First workflow</a>.</p><h2 id="sitecore-jss-modes">Sitecore JSS: modes</h2><p>When you want to start developing in Sitecore JSS you can choose beween four flavours. For only one of them Sitecore isn't required.</p><ul><li> <em><strong>Disconnected mode</strong></em> - As I described before this mode is pretty straightforward. Does not require Sitecore and it's just like developing a plain ReactJS website with webpack. In one of the next posts I'll dig deeper into modifying the default app scaffold to make it more mature. </li><li> <em><strong>Connected mode</strong></em> - This is the mode I am focussing on in this blog. A connection to Sitecore is needed as data will be retrieved from Sitecore. Sitecore templates and items are governed from Sitecore. </li><li> <em><strong>Integrated mode</strong></em> - After deploying your app, it will be run in Sitecore. A Node server in Sitecore will render your app through SSR. Note: Deploying your app through <code>JSS deploy app --includeContent --includeDictionary</code> will alway make this mode available. After deployment open a page in the Experience Editor and you're good to go.  </li><li> <em><strong>API mode</strong></em> - Especially for people who don't want all the overhead stuff and do not want to be bothered with all the Sitecore JSS specific stuff (as someone said to me: 'I'd rather start studying quantum physics'). Keep in mind that when you start this way you do not have the advantages of the routes, components, content API's and all other great stuff the JSS team provides us with. </li></ul><h2 id="setting-up-the-connection">Setting up the connection</h2><p>The <a href="https://jss.sitecore.net/docs/fundamentals/cli">JSS CLI</a> is a great tool which takes a lot of work out of your hands like: setting up, running modes and deploying your app in several ways. After creating your app with <code>jss create [appname] [app type]</code> you have to set up the connection information. This can be done manually but it's easier to do it this way. Running <code>jss setup</code> will ask you some questions and generates the scjssconfig.json file which will be used for the connection to your Sitecore instance.</p><figure class="kg-image-card"><img src="https://ghost-azure-gary.azurewebsites.net/content/images/2018/08/scjssconfig.png" class="kg-image"></figure><p>After creating this file make sure to check your configuration to see if there are no typo's and stuff ;-) Next, you deploy the configuration to Sitecore. Using the <code>jss deploy config</code> command two Sitecore configuration files will be added to the <code>/App_Config/Include/zzz</code> folder: a file with a secret token for deployment and the site configuration plus the GraphQl endpoint config. When you do not have a local instance of Sitecore you can always change the value of the <code>instancePath</code> in your scjssconfig.json file, point to a local folder and copy it afterwards to your Sitecore instance. You can also change the location where the files are copied changing the <code>package.json</code> property <code>sitecoreConfigPath</code> to something else.</p><h2 id="sitecore-jss-deployment">Sitecore JSS Deployment</h2><p>Now that we've configured the connections and deployed our configuration we can deploy our app. Before doing so you have to do some <a href="https://jss.sitecore.net/docs/getting-started/app-deployment">configuration</a> in Sitecore to prepare usage and deployment of your app. There are some options to choose  from using the command <code>jss deploy</code>:</p><ul><li> <em><strong>jss deploy app</strong></em> - This is the shorthand for files and items but know that you have less control over your deployment flow. Your entire app is built in production mode and imported into Sitecore. It will create templates, a folder for your media library assets, a layout (<code>/Views/JssApp.cshtml</code>) several renderings (based on template <code>json rendering</code>) and a start node (app) for your site with an empty dictionary folder for translations and a folder with your components. But there is no content. Use the switch <code>--help</code> to see more options. </li><li> <em><strong>jss deploy files</strong></em> - Will build your app and deploy it to Sitecore. No templates, components and content are added. Just the distro which is built. Using the <code>--clean</code> switch also the old data will be wiped first. </li><li> <em><strong>jss deploy items</strong></em> - This is my favorite as it can do a lot! By default it creates a manifest and package and then deploys it. As with <code>deploy app</code> this command also does not include the dictionary and content items by default. So you need to use switches for this to do so. Take into account that your content will not be wiped using the <code>--wipe</code> switch. For this action use the following approach: first create the manifest (or when you ran the <code>jss deploy app</code> or <code>jss deploy items</code> it's already there).   Change the manifest and set <code>wipeExisting</code> to <code>true</code>. This will allow wiping all content and replace it with new ones. After this you haveto use  the <code>--skipManifest</code> switch which will use the existing manifest. If you don't do this your existing manifest will be overwritten and edited content items still are not updated in Sitecore. For our demo we want to included data so we use the <code>-d</code> and <code>-c</code> switches too. <strong>Important</strong>: Changing content means you'll need to regenerate your manifest as this file holds the content you are importing (not the YAML files). And don't forget the <code>wipeExisting</code> switch! </li></ul><h2 id="sitecore-jss-connected-mode">Sitecore JSS: connected mode</h2><p>Now that you have deployed your app and also have some content imported it's time to kick off the development server in connected mode. Run the <code>jss start:connected</code> command, some magic happens in the console and suddenly your default browser opens a webpage pointing to your dev server on port 3000.</p><figure class="kg-image-card"><img src="https://ghost-azure-gary.azurewebsites.net/content/images/2018/08/lh3000.png" class="kg-image"></figure><p>Not really what you expected but do not be alarmed! The 404 is normal behaviour. Let me explain why. I check the network tab to see what happens:</p><figure class="kg-image-card"><img src="https://ghost-azure-gary.azurewebsites.net/content/images/2018/08/call01-1.png" class="kg-image"></figure><p>As you can see the call was executed which means we have a connection and we got data back. But it looks like somethin's missing and a quick check points to the workflow state of the item:</p><figure class="kg-image-card"><img src="https://ghost-azure-gary.azurewebsites.net/content/images/2018/08/call00.png" class="kg-image"></figure><figure class="kg-image-card"><img src="https://ghost-azure-gary.azurewebsites.net/content/images/2018/08/call02.png" class="kg-image"></figure><p>So I changed the workflow state of the item to published, refreshed the page of my dev server and this time I get an error saying that fields is <em>undefined</em>. Ugh!</p><figure class="kg-image-card"><img src="https://ghost-azure-gary.azurewebsites.net/content/images/2018/08/call003.png" class="kg-image"></figure><p>The inspector (network tab / Response) shows me more data. I now can see Sitecore context data and route information. Also the main placeholder with my components (<em>About</em> and <em>ContentBlock</em>) is available.</p><figure class="kg-image-card"><img src="https://ghost-azure-gary.azurewebsites.net/content/images/2018/08/call004.png" class="kg-image"></figure><p>As you can see we do not see the field values of the components. Reason for this is that they are also in the <code>Development Mode</code> workflow state.</p><figure class="kg-image-card"><img src="https://ghost-azure-gary.azurewebsites.net/content/images/2018/08/call005.png" class="kg-image"></figure><p>Changing the states to <code>Published</code> gave me the result I needed. Also in the <code>Published</code> state I now can change content in the Content Editor. Changes will be visible in my development environment after I hit F5.</p><figure class="kg-image-card"><img src="https://ghost-azure-gary.azurewebsites.net/content/images/2018/08/call006.png" class="kg-image"></figure><h2 id="sitecore-jss-development-workflow-states">Sitecore JSS:  Development Workflow states</h2><blockquote>The JSS import process is designed to gracefully skip items to which the configured import user does not have write permission. This allows you to utilize Sitecore Security to prevent the import from overwriting content which should no longer be "developer-owned."</blockquote><blockquote>To further facilitate this, JSS includes a content workflow which is automatically applied to all generated templates. This workflow defines Development Mode and Content Mode states to designate the current "ownership" of a content item.</blockquote><p>Notice that when publishing Sitecore content it is automatically  put into the <code>Development Mode</code> workflow state.<br>Items can be set in one of the three states:</p><ul><li> <em><strong>Development Mode</strong></em> -  Import can overwrite field values and route item layout. This fully facilitates the <a href="https://jss.sitecore.net/docs/fundamentals/dev-workflows/code-first">Code First</a> approach. </li><li> <em><strong>Content Mode</strong></em> - <em>Import user</em> is denied item write access. Import will skip writes on the item. For route items, this means that any rendering changes or updates to datasource items are also skipped. This still facilitates the <a href="https://jss.sitecore.net/docs/fundamentals/dev-workflows/code-first">Code First</a> approach, but with limitations. </li><li> <em><strong>Published</strong></em> - Final state of the JSS Development workflow. The items are no longer governed through manifest deployment in your deployment process. After the disconnected approach you shift into the <a href="https://jss.sitecore.net/docs/fundamentals/dev-workflows/sitecore-first">Sitecore First</a> approach. </li></ul>
